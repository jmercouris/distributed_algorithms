\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\begin{document}
\begin{center}
  \Large Assignment 3 \\
  \large Distributed Algorithms
\end{center}
\begin{flushright}
  \begin{tabular}{ll}
    \textbf{Group 11} \\
    Dan Drewes        \\ 
    Manuela Hopp      \\ 
    John Mercouris    \\
    Malte Siemers     \\
  \end{tabular} 
\end{flushright}

\section*{Exercise 3.1: Distributed Garbage Collection}
\subsection*{a)}
\begin{tabular}{r|p{10cm}}
CORBA & No built in carbage collection, except that non-persistent objects are deactivated and removed automatically when the
session expires or hangs, or when a time limit has expired \\[0.2cm]
Microsoft DCOM & References held by clients of interfaces are released when, for example, the client process crashed, or the
network connection was lost \\[0.2cm]
Java RMI & A reference-counting garbage collection algorithm is used. The RMI runtime keeps track of all live references within
each Java virtual machine When there is no live remote or local reference, the object is passed to the garbage collector.\\[0.2cm]
.NET Remoting & Garbage is collected on a leased based lifetime. The garbage collector runs in cycles and only starts to check for
live references to objects when their lease lifetime has expired. An object then is collected when no live references exist
anymore.
\end{tabular}

%\subsection*{b)} see implementation
\subsection*{c)} Generational garbage collectors divide the objects according to their age and concentrate on young objects since these are more likely to be garbage. Collections of young objects only are usually fast and the system is not freezed for a long time. However, such a garbage collector still has to run a collection on all objects sometimes which then freezes the system for about the same time as a normal garbage collection on all objects does.
Parallel garbage collectors solve the problem by running the collection parallel to the client, which means that the garbage collector does introduce some overhead but does not freeze the system.

\section*{Exercise 3.2: Mutual Exclusion}
  \subsection*{a)} % Lamport: The broadcast algorithm (Lamport, 1978) has been introduced in the lecture. The algorithm requires FIFO channels. Assume, we drop this precondition. Construct an example in which the algorithm does not work properly anymore
  \subsection*{b)} % Ricart and Agrawala
    \paragraph*{(a)} % Is this algorithm deadlock-free? Give a reasonable answer
    \paragraph*{(b)} % Modify the broadcast algorithm of Ricart and Agrawala such that (at maximum) k ∈ N proces- ses are able to enter the critical section instead of just one.
  \subsection*{c)} % Maekawa
    \paragraph*{(a)} % The process mesh-algorithm (Maekawa, 1985) is based on the assumption that n processes are arranged in a quadratic mesh with an edge length of √n. Consider a situation where this assumption is not given (n is not a square number). Is it still feasible to use the algorithm?
    \paragraph*{(b)} % It is also possible to apply a triangular arrangement instead of a quadratic one. Nevertheless the triangular arrangement is also not optimal. What are advantages and disadvantages of a minimal arrangement? How do you construct granting sets for this?
  \subsection*{d)} % Suzuki and Kasami Implement the improved Token Ring Solution (Suzuki and Kasami, 1985) for mutual exclusion using the simulation framework. Now, implement a behavior such that in (random) time intervals (random- ly) chosen nodes try to access the resource. Choose your time intervals careful such that there are phases in which only a few (or no) nodes access the resource as well as phases in which multiple nodes try to access it.

\end{document}


% (3.1 a), c) and 3.2 a), b), c))